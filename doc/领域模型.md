# 一、DDD 为什么这样拆文件？

## 1. 本质：把业务概念显式变成代码结构

传统写法是「先想到什么写什么」：

Controller → Service → DAO，业务规则散落在 Service、DAO、甚至 SQL 里。

DDD 的想法是：业务里有什么概念，代码里就有什么结构。

不是按「技术层」拆，而是按「业务概念」拆。

这些文件就是在回答几个问题：

* 业务里有哪些核心概念？
* 它们各自有哪些规则？
* 它们之间怎么协作？

---

# 二、每个文件存在的意义

## 1. auth\_type.go —— 登录方式

业务里有：游客、手机验证码、阿里、微信 4 种登录方式。

如果到处写 0、1、2、3，含义不清，也难改。

DDD 做法：* 定义 AuthType 和常量：AuthTypeGuest、AuthTypeMobile 等

* 方法名就能表达业务含义，比如 authType.IsMobile()

目的：把「登录方式」变成一个清晰的业务概念，而不是魔法数字。

---

## 2. user\_id.go / app\_id.go —— 值对象

ID 看起来是 int64，但业务上不是任意数字，需要校验、格式约定。

DDD 做法：* 用 UserID、AppID 包装

* 在 NewUserID 里做合法性校验
* 编译期就能区分「用户ID」和「应用ID」

目的：防止 ID 被乱用、乱传，让类型本身表达业务含义。

---

## 3. app.go —— 应用实体

业务里有一个概念：每个 App 有自己的微信/阿里等配置。

如果配置散落在各处，每次加新配置都要改很多地方。

DDD 做法：* 用 App 实体集中承载「应用配置」

* 仓储只负责查库，领域层定义「App 里应该有什么」

目的：让「应用配置」有一个统一、稳定的结构，和业务语言对应。

---

## 4. user.go —— 用户聚合根（最核心）

用户相关的业务规则很多：

* 同一 (app + 设备 + 登录方式) 对应一个用户
* 登录后要更新 IP、设备、渠道
* 手机/微信/阿里登录要绑定对应信息

如果都写在 Service 里，会变成一堆 if-else，不好维护。

DDD 做法：* 把规则封装进 User 的方法：UpdateIfChanged、BindMobile、BindWechat 等

* Service 只负责：查 User → 调 User 的方法 → 保存
* 规则在哪、怎么改，一目了然

目的：让「用户」这个业务概念自己负责自己的规则，而不是到处散落。

---

## 5. user\_repository.go / app\_repository.go —— 仓储接口

领域层只关心「我要查用户」「我要查应用」，不关心 MySQL、Redis 还是别的。

DDD 做法：* 在领域层定义 UserRepository、AppRepository 接口

* 在基础设施层用 MySQL/GORM 实现

目的：* 领域层不依赖数据库

* 换存储实现时，领域层和业务规则不用动
* 测试时可以轻松 Mock

---

# 三、一句话总结


| 文件               | 本质     | 一句话                               |
| ------------------ | -------- | ------------------------------------ |
| auth\_type.go      | 业务枚举 | 把登录方式变成可读、可扩展的业务概念 |
| user\_id / app\_id | 值对象   | 让 ID 有类型、有校验，不被乱用       |
| app.go             | 实体     | 把「应用配置」集中管理               |
| user.go            | 聚合根   | 把「用户」相关规则集中到 User 上     |
| \_repository.go    | 仓储接口 | 让领域层不依赖具体存储实现           |
