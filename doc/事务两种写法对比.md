# 事务两种写法对比

应用层需要「多步数据库操作要么全成功要么全回滚」时，可以用两种方式写事务：**回调写法**（GORM 封装）和 **显式写法**（自己 Begin/Commit/Rollback）。效果一致，显式写法多一层 panic 时的回滚保护。

---

## 一、写法一：回调函数（db.Transaction）

GORM 提供 `db.Transaction(func(tx *gorm.DB) error { ... })`，内部会：开事务 → 执行回调 → 回调返回 nil 则 Commit，返回 err 则 Rollback。

### 代码示例

```go
func (s *LoginService) GuestLogin(c *gin.Context, req dto.GuestLoginReq) (*dto.GuestLoginResp, error) {
	// ... 取参数、查 App（可在事务外）...

	var user *identity.User
	err = s.db.Transaction(func(tx *gorm.DB) error {
		appRepoTx := repository.NewBizAppRepository(tx)
		userRepoTx := repository.NewBizUserRepository(tx)

		app, e := appRepoTx.FindByProjectID(int32(projectId))
		if e != nil || app == nil {
			return e // 或 return fmt.Errorf("app not found")
		}
		u, e := userRepoTx.FindByUk(app.ID().Value(), authType, oaid, deviceId)
		if e != nil {
			return e // 回调 return err → GORM 内部会 Rollback
		}
		if u == nil {
			return fmt.Errorf("user nil")
		}
		// ... 按需 UpdateByFieldmap ...
		user = u
		return nil // 回调 return nil → GORM 内部会 Commit
	})
	if err != nil {
		return nil, err
	}
	// ... 生成 token、返回 ...
}
```

### 特点

- **Begin/Commit/Rollback 在 GORM 内部**，代码里看不到显式调用。
- 逻辑清晰：回调里只写业务，返回 `nil` 即提交，返回 `err` 即回滚。
- 若回调内 **panic**，GORM 是否自动 Rollback 依赖其实现，不一定保证。

---

## 二、写法二：显式 Begin / Commit / Rollback

自己调用 `Begin()`，成功则最后 `Commit()`，任一步出错或 panic 则 `Rollback()`。

### 代码示例

```go
func (s *LoginService) GuestLogin(c *gin.Context, req dto.GuestLoginReq) (*dto.GuestLoginResp, error) {
	// ... 取参数、查 App（可在事务外）...

	// 1. 显式开始事务
	tx := s.db.Begin()
	if tx.Error != nil {
		return nil, fmt.Errorf("tx begin failed: %w", tx.Error)
	}
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback() // panic 时也要回滚
		}
	}()

	var user *identity.User
	userRepoTx := repository.NewBizUserRepository(tx)

	u, e := userRepoTx.FindByUk(appId, authType, oaid, deviceId)
	if e != nil {
		tx.Rollback()
		return nil, e
	}
	if u == nil {
		tx.Rollback()
		return nil, fmt.Errorf("user nil after FindByUk")
	}
	// ... 按需 UpdateByFieldmap ...
	if e = userRepoTx.UpdateByFieldmap(u.ID(), userUpateParam); e != nil {
		tx.Rollback()
		return nil, e
	}
	user = u

	// 2. 显式提交
	if e = tx.Commit().Error; e != nil {
		tx.Rollback()
		return nil, fmt.Errorf("tx commit failed: %w", e)
	}

	// ... 生成 token、返回 ...
}
```

### 特点

- **Begin / Commit / Rollback 都在代码里可见**，便于排查和培训。
- 任一步出错都先 `tx.Rollback()` 再 `return`，语义明确。
- `defer recover()` 里再 `Rollback()`，**panic 时也会回滚**，比单纯回调多一层保护。

---

## 三、对比小结

| 项目         | 回调写法 `db.Transaction(fn)`     | 显式写法 Begin / Commit / Rollback   |
|--------------|------------------------------------|----------------------------------------|
| 开始事务     | GORM 内部 `Begin()`                | 自己写 `tx := s.db.Begin()`            |
| 成功时提交   | 回调返回 `nil` 后内部 `Commit()`   | 自己写 `tx.Commit()`                   |
| 失败时回滚   | 回调返回 `err` 后内部 `Rollback()` | 自己写 `tx.Rollback()` 再 `return`     |
| panic 时回滚 | 依赖 GORM 实现                     | `defer recover()` 里 `tx.Rollback()`   |
| 代码风格     | 业务集中在一个闭包内               | 顺序写，一眼看到事务边界               |

两种写法在「成功提交 / 失败回滚」上的**效果一致**；显式写法多保证了一步 **panic 时也回滚**。

---

## 四、使用建议

- 想少写几行、逻辑都塞在一个闭包里：用 **回调写法**。
- 想看清楚事务边界、或希望 panic 一定回滚：用 **显式写法**。

项目里若已有「显式写法」示例（如当前 `login_service.go`），建议同类型写事务的接口统一用一种，避免混用增加理解成本。
