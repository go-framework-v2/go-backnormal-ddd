# 登录接口限流实现指南

限流目的：防止同一 IP/设备在短时间内大量请求登录接口（刷接口、撞库、压垮 DB）。常见做法有**按 IP 限流**（简单）和**按 IP+接口**限流（更细）。下面给出两种实现方式：**单机内存版**（无新依赖）、**多机 Redis 版**（多实例部署时用）。

---

## 一、思路简述

- **限流键**：一般用「客户端 IP」，必要时可加 `projectId` 或 `deviceId`（需从请求里取）。
- **规则**：例如「同一 IP 每分钟最多 30 次登录请求」，超过则返回 **429 Too Many Requests**。
- **实现方式**：
  - **单机**：用内存（map + 滑动窗口或令牌桶），只对本进程生效，多实例各自算。
  - **多机**：用 Redis 计数 + 过期时间，多实例共享同一计数。

---

## 二、方式一：单机内存限流（无新依赖）

用 `map[key][]time.Time` 记录该 key 最近几次请求时间，超过次数就拒绝；并定期清理过期时间，避免 map 无限变大。

### 1. 新建限流中间件

在 `src/middleware/ratelimit/ratelimit.go` 下新建（若无 `ratelimit` 目录则先建）：

```go
package ratelimit

import (
	"net/http"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/go-framework-v2/go-access/access"
	"go.uber.org/zap"
)

// IPLimit 按 IP 的滑动窗口限流：每个 key 在 window 内最多 max 次请求
type IPLimit struct {
	mu      sync.Mutex
	records map[string][]time.Time // key -> 最近请求时间
	max     int                    // 窗口内允许的最大次数
	window  time.Duration          // 时间窗口，如 1 * time.Minute
}

// NewIPLimit max=30, window=1*time.Minute 表示每 IP 每分钟最多 30 次
func NewIPLimit(max int, window time.Duration) *IPLimit {
	return &IPLimit{
		records: make(map[string][]time.Time),
		max:     max,
		window:  window,
	}
}

// Key 从 c 取限流 key，默认用 ClientIP
func (l *IPLimit) Key(c *gin.Context) string {
	return c.ClientIP()
}

// Allow 返回是否允许本次请求；若不允许会写 429 并 abort
func (l *IPLimit) Allow(c *gin.Context) bool {
	key := l.Key(c)
	now := time.Now()

	l.mu.Lock()
	defer l.mu.Unlock()

	// 只保留在 window 内的请求时间
	cut := now.Add(-l.window)
	var kept []time.Time
	for _, t := range l.records[key] {
		if t.After(cut) {
			kept = append(kept, t)
		}
	}
	if len(kept) >= l.max {
		l.records[key] = kept
		return false
	}
	l.records[key] = append(kept, now)
	return true
}

// Middleware 返回 gin 中间件：超出限制时 429 并 abort
func (l *IPLimit) Middleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		if !l.Allow(c) {
			zap.S().Warn("rate limit exceeded", zap.String("ip", c.ClientIP()))
			c.AbortWithStatusJSON(http.StatusOK, access.GetErrorResult(http.StatusTooManyRequests, nil, "请求过于频繁，请稍后再试"))
			return
		}
		c.Next()
	}
}
```

说明：`access.GetErrorResult` 若你的项目没有或签名不同，可改成直接：

```go
c.AbortWithStatusJSON(http.StatusOK, gin.H{"code": 429, "msg": "请求过于频繁，请稍后再试"})
```

### 2. 在登录路由上挂限流

在 `api/route_login.go` 里，只对登录相关接口加限流，例如：

```go
import (
	"time"
	"user_center_go/src/middleware/ratelimit"
)

// 例如：每 IP 每分钟最多 30 次登录请求
var loginLimiter = ratelimit.NewIPLimit(30, 1*time.Minute)

func RouteLogin(r *gin.Engine) {
	initLoginService()

	loginGroup := r.Group("/user/login")
	loginGroup.Use(loginLimiter.Middleware()) // 该组下所有接口都限流
	{
		loginGroup.POST("/guest", GuestLogin)
		loginGroup.POST("/wechat", nil)
		// ...
	}
}
```

若只想对 `/guest` 限流，可以单独再包一层：

```go
loginGroup.POST("/guest", loginLimiter.Middleware(), GuestLogin)
```

（注意：`Middleware()` 返回的是 `gin.HandlerFunc`，可以当中间件用；若你希望「只对 POST /guest 限流」且不用 Use，需要把限流逻辑包成一层，再调 `GuestLogin`。）

---

## 三、方式二：多机 Redis 限流（多实例部署）

多实例时，内存里的计数不共享，需要 Redis 做「同一 key 的计数」。

- **键**：例如 `ratelimit:login:{{ip}}`
- **规则**：例如每 key 在 1 分钟内最多 30 次：用 `INCR` + `EXPIRE`（第一次设过期），或用 Lua 保证「计数+过期」原子。
- **超出**：返回 429。

示例逻辑（需你项目已有 Redis 客户端）：

```go
// 伪代码
key := "ratelimit:login:" + c.ClientIP()
n, err := redis.Incr(ctx, key)
if err != nil { /* 降级：放过或 500 */ }
if n == 1 {
	redis.Expire(ctx, key, 1*time.Minute)
}
if n > 30 {
	c.AbortWithStatusJSON(200, gin.H{"code": 429, "msg": "请求过于频繁"})
	return
}
c.Next()
```

你已有 `config.Cfg.Redis` 和 `res` 里若已有 Redis 连接，可在 `middleware/ratelimit` 里加一个 `RedisLimit` 结构体，按上面逻辑实现即可。

---

## 四、建议

- **先上单机内存版**：无新依赖、易落地，单实例或实例数不多时够用。
- **再按需上 Redis 版**：多实例且要「全局限流」时再上，并做好 Redis 不可用时的降级（例如放过请求或返回 503）。

参数建议：登录接口可设为「每 IP 每分钟 30～60 次」，再按压测或线上情况调 `max` 和 `window`。

---

## 五、如何测试限流

### 预期现象

- 当前配置：每 IP 每分钟最多 **30** 次。
- **前 30 次**：HTTP 200，body 里为正常登录结果（本项目成功为 **code: 200**，含 `userId`、`token` 等）。
- **第 31 次及以后**（同一分钟内）：HTTP 仍为 200，但 body 里 **code 为 429**，msg 为「请求过于频繁，请稍后再试」。

接口统一用 HTTP 200 包 body，是否被限流看 **body.code === 429**，不是看 HTTP 状态码。

---

### 操作指南（推荐流程）

| 步骤 | 说明 |
|------|------|
| 1. 启动服务 | 在项目根目录启动 `user_center_go`，确认监听端口（如 8091）。 |
| 2. 执行脚本 | 在项目根目录执行：`./scripts/test_rate_limit.sh http://127.0.0.1:8091 1`（端口和 projectId 按实际修改；不写参数时默认 `http://127.0.0.1:8080` 和 projectId=1）。 |
| 3. 看输出 | 前 30 次应显示「通过 (code=200)」，第 31 次起应显示「被限流 (429)」。 |
| 4. 重测 | 限流按 IP、按 1 分钟窗口。若要重新测满 30 次，可**重启服务**（内存计数清空）或等 1 分钟后再跑脚本。 |

**脚本说明**：`scripts/test_rate_limit.sh` 使用 `grep` 从 JSON 中解析 `code`，**不依赖 jq**，装好 curl 即可运行。

**若 35 次都显示「通过」**：说明未触发限流。请确认：① 只起了一个服务进程；② 脚本里的 `BASE` 与真实服务地址、端口一致（例如服务在 8091 则传 `http://127.0.0.1:8091`）。

---

### 方法一：一键脚本（推荐）

```bash
./scripts/test_rate_limit.sh
# 或指定地址和 projectId（端口按实际修改，如 8091）：
./scripts/test_rate_limit.sh http://127.0.0.1:8091 1
```

### 方法二：curl 循环

先启动服务，再执行（`BASE`、`PROJECT_ID` 按实际修改）：

```bash
BASE="http://127.0.0.1:8091"
PROJECT_ID="1"
for i in $(seq 1 35); do
  echo "=== 第 $i 次 ==="
  curl -s -X POST "$BASE/user/login/guest" \
    -H "Content-Type: application/json" \
    -H "projectId: $PROJECT_ID" \
    -d '{"data":{"deviceId":"rate-test-dev","oaid":"","model":"test","realChannel":"test"}}' \
    | grep -o '"code":[0-9]*'
done
```

前 30 次为 `"code":200`，第 31 次起为 `"code":429` 即表示限流生效。

### 方法三：临时调小限流数快速测

若不想发 31 次请求，可临时把 `route_login.go` 里改成更小的值，例如：

```go
var loginLimiter = ratelimit.NewIPLimit(3, 1*time.Minute) // 临时改为 3 次/分钟
```

然后执行 5 次 curl：前 3 次通过，第 4、5 次应为 429。测完改回 30。

### 方法四：用 .http 文件手点（可选）

使用项目里的 `doc/http/login_guest.http`，在 IDE 里多次点击「Run」：前 30 次正常（code=200），第 31 次起响应里会出现 `"code":429`。适合随手验证，不便于自动化。`.http` 里的 URL 端口请按实际服务修改（如 8091）。

---

**注意**：限流按 **IP** 统计。本机测时所有请求来自同一 IP；若 1 分钟内测过其他登录请求，会占用配额，可能不足 30 次就 429。重测请按「操作指南」中步骤 4：重启服务或等 1 分钟后再跑。
