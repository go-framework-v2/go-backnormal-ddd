# 登录接口限流实现指南

限流目的：防止同一 IP/设备在短时间内大量请求登录接口（刷接口、撞库、压垮 DB）。常见做法有**按 IP 限流**（简单）和**按 IP+接口**限流（更细）。下面给出两种实现方式：**单机内存版**（无新依赖）、**多机 Redis 版**（多实例部署时用）。

---

## 一、思路简述

- **限流键**：一般用「客户端 IP」，必要时可加 `projectId` 或 `deviceId`（需从请求里取）。
- **规则**：例如「同一 IP 每分钟最多 30 次登录请求」，超过则返回 **429 Too Many Requests**。
- **实现方式**：
  - **单机**：用内存（map + 滑动窗口或令牌桶），只对本进程生效，多实例各自算。
  - **多机**：用 Redis 计数 + 过期时间，多实例共享同一计数。

---

## 二、方式一：单机内存限流（无新依赖）

用 `map[key][]time.Time` 记录该 key 最近几次请求时间，超过次数就拒绝；并定期清理过期时间，避免 map 无限变大。

### 1. 新建限流中间件

在 `src/middleware/ratelimit/ratelimit.go` 下新建（若无 `ratelimit` 目录则先建）：

```go
package ratelimit

import (
	"net/http"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/go-framework-v2/go-access/access"
	"go.uber.org/zap"
)

// IPLimit 按 IP 的滑动窗口限流：每个 key 在 window 内最多 max 次请求
type IPLimit struct {
	mu      sync.Mutex
	records map[string][]time.Time // key -> 最近请求时间
	max     int                    // 窗口内允许的最大次数
	window  time.Duration          // 时间窗口，如 1 * time.Minute
}

// NewIPLimit max=30, window=1*time.Minute 表示每 IP 每分钟最多 30 次
func NewIPLimit(max int, window time.Duration) *IPLimit {
	return &IPLimit{
		records: make(map[string][]time.Time),
		max:     max,
		window:  window,
	}
}

// Key 从 c 取限流 key，默认用 ClientIP
func (l *IPLimit) Key(c *gin.Context) string {
	return c.ClientIP()
}

// Allow 返回是否允许本次请求；若不允许会写 429 并 abort
func (l *IPLimit) Allow(c *gin.Context) bool {
	key := l.Key(c)
	now := time.Now()

	l.mu.Lock()
	defer l.mu.Unlock()

	// 只保留在 window 内的请求时间
	cut := now.Add(-l.window)
	var kept []time.Time
	for _, t := range l.records[key] {
		if t.After(cut) {
			kept = append(kept, t)
		}
	}
	if len(kept) >= l.max {
		l.records[key] = kept
		return false
	}
	l.records[key] = append(kept, now)
	return true
}

// Middleware 返回 gin 中间件：超出限制时 429 并 abort
func (l *IPLimit) Middleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		if !l.Allow(c) {
			zap.S().Warn("rate limit exceeded", zap.String("ip", c.ClientIP()))
			c.AbortWithStatusJSON(http.StatusOK, access.GetErrorResult(http.StatusTooManyRequests, nil, "请求过于频繁，请稍后再试"))
			return
		}
		c.Next()
	}
}
```

说明：`access.GetErrorResult` 若你的项目没有或签名不同，可改成直接：

```go
c.AbortWithStatusJSON(http.StatusOK, gin.H{"code": 429, "msg": "请求过于频繁，请稍后再试"})
```

### 2. 在登录路由上挂限流

在 `api/route_login.go` 里，只对登录相关接口加限流，例如：

```go
import (
	"time"
	"user_center_go/src/middleware/ratelimit"
)

// 例如：每 IP 每分钟最多 30 次登录请求
var loginLimiter = ratelimit.NewIPLimit(30, 1*time.Minute)

func RouteLogin(r *gin.Engine) {
	initLoginService()

	loginGroup := r.Group("/user/login")
	loginGroup.Use(loginLimiter.Middleware()) // 该组下所有接口都限流
	{
		loginGroup.POST("/guest", GuestLogin)
		loginGroup.POST("/wechat", nil)
		// ...
	}
}
```

若只想对 `/guest` 限流，可以单独再包一层：

```go
loginGroup.POST("/guest", loginLimiter.Middleware(), GuestLogin)
```

（注意：`Middleware()` 返回的是 `gin.HandlerFunc`，可以当中间件用；若你希望「只对 POST /guest 限流」且不用 Use，需要把限流逻辑包成一层，再调 `GuestLogin`。）

---

## 三、方式二：多机 Redis 限流（多实例部署）

多实例时，内存里的计数不共享，需要 Redis 做「同一 key 的计数」。

- **键**：例如 `ratelimit:login:{{ip}}`
- **规则**：例如每 key 在 1 分钟内最多 30 次：用 `INCR` + `EXPIRE`（第一次设过期），或用 Lua 保证「计数+过期」原子。
- **超出**：返回 429。

示例逻辑（需你项目已有 Redis 客户端）：

```go
// 伪代码
key := "ratelimit:login:" + c.ClientIP()
n, err := redis.Incr(ctx, key)
if err != nil { /* 降级：放过或 500 */ }
if n == 1 {
	redis.Expire(ctx, key, 1*time.Minute)
}
if n > 30 {
	c.AbortWithStatusJSON(200, gin.H{"code": 429, "msg": "请求过于频繁"})
	return
}
c.Next()
```

你已有 `config.Cfg.Redis` 和 `res` 里若已有 Redis 连接，可在 `middleware/ratelimit` 里加一个 `RedisLimit` 结构体，按上面逻辑实现即可。

---

## 四、建议

- **先上单机内存版**：无新依赖、易落地，单实例或实例数不多时够用。
- **再按需上 Redis 版**：多实例且要「全局限流」时再上，并做好 Redis 不可用时的降级（例如放过请求或返回 503）。

参数建议：登录接口可设为「每 IP 每分钟 30～60 次」，再按压测或线上情况调 `max` 和 `window`。
